function opts = lw_opts(varargin)
% Linewidth Options Setter
% Last Updated: April 2013
% Author: Paul J. Ganssle, Pines Lab, UC Berkeley, Berkeley, CA
%
% Function for generating an options structure for use with the
% calculate_linewidth tool. This is primarily for defining the unusual
% aspects of the problem and bringing in necessary constants.
%
% Passing 'get_component_names' retrieves a default library of components.
% Passing 'get_component' as the first argument and a valid name as the
% second retrieves a component struct like the one generated by
% add_lw_comp()
%
% Options:
% ------------------------------------------------------------------------
% 'CompNames':		The order of gasses included. Names must be values in the
%					'get_component_names' library. Default value is identical
%					to the 'get_component_names' library.
%
% 'add_comps':		Additional components - structs as generated by
%					add_lw_comp(); Pass either one struct or a cell array.
%
% 'ElementNames':	List of elements to include in the calculation.
%
% 
%
% ------------------------------------------------------------------------
%
%
% Prototypes:
% complist = lw_opts('get_component_names');
% comp = lw_opts('get_component', 'component_name');
% opts = lw_opts(lwopts, 'name', 'value', 'name2', value2, ...);
% opts = lw_opts('name', 'value', 'name2', value2, ...);

% Create the isotopes structure.
Isotopes = [
	add_iso('Rb',				[85, 87], ...	% Two main isotopes of Rb
			[84.911789738, 86.9091835], ...	% Mass in au
							  [-5/2, -3/2], ...	% Spins of each isotope.
						 [0.7217, 0.2783], ...	% Natural abundance.
					      [4.312, -4040]),...	% Virial coefficients
	...
	add_iso('Cs',					  133, ...	% One isotope of Cs.
							 132.905451933, ...	% Mass in au
										  7/2, ...  % Spins of each isotope.
											 1, ...	% Natural abundance.								  
						   [4.165, -3830]),...	% Virial coefficients
	...
	add_iso('K',		  [39, 40, 41], ...	% Three main isotopes of K
			  [38.96370668,39.96399848, ...  % Mass in au
							  40.96182576], ...	
							[3/2, -4, 3/2], ...	% Spins of each isotope.
		[0.932581, 1.17e-4, 0.067302], ...	% Natural abundance.
							 [4.402,-4453]),...	% Virial coefficients
	];

% Create the components structure
Components = add_lw_comp('N2', 28.014, {'K', {'sd', 7.9e-23, ...
    'sq', [3.5e-15, 3.9e-15], 'D0', 0.2}}, {'Rb', {'sd', 1e-22, ...
    'sq', [5.8e-15, 4.3e-15], 'D0', 0.19}}, {'Cs', {'sd', 5.5e-22, ...
    'sq', [5.5e-15, 6.4e-15], 'D0', 0.1}}));


if(isstruct(varargin{1}))
	o = varargin{1};
	varargin(1) = [];
	
	opt = merge_struct(opt, o);
end


% Process options first.
% Max number of SVDs - default is max num possible.
ns = find(strcmp(varargin, 'nSVDs'));
if(~isempty(ns))
	NS = varargin{ns(1)+1};
	
	if(~isnumeric(NS))
		error('Number of SVDs must be numeric.');
	else
		if(isscalar(NS))
			opt.nSVDs(:) = NS;
		else
			opt.nSVDs(:) = NS(1:2);
		end
	end

	varargin([ns, ns+1]) = [];
end

% Alpha mode.
a = find(strcmp(varargin, 'alpha_mode'));
if(~isempty(a))
	am = varargin{a(1)+1};
	if ischar(am) && find(strcmpi(am, {'BRD', 'lcurve', 'l-curve'}), 1, 'first')
		if strcmpi(am, 'BRD')
			am = 'BRD';
		elseif find(strcmpi(am, {'lcurve', 'l-curve'}), 1, 'first')
			am = 'lcurve';
		end		
		
		opt.alpha_mode = am;		
	else
		warning('Invalid alpha_mode passed as parameter. Using default value instead.');
	end
end

a = find(strcmp(varargin, 'alpha_log'));
if(~isempty(a))
	os = varargin{a(1)+1};
	
	try
		opt.alpha_log = logical(os);
	catch %#ok
		warning('Alpha_log parameter could not be converted to logical. Using default value of true instead.')
		opt.alpha_log = true;
	end
end

brd = false;
lcurve = false;
if(strcmp(opt.alpha_mode, 'BRD'))
	brd = true;
elseif(strcmp(opt.alpha_mode, 'lcurve'))
	lcurve = true;
end

% Number of alphas
a = find(strcmp(varargin, 'nAlphas'));
if(~isempty(a))
	na = varargin{a(1)+1};
	if(isnumeric(na) && isscalar(na) && na > 0)
		opt.nAlphas = na;
	else
		if strcmp(opt.alpha_mode, 'BRD')
			opt.nAlphas = 50;
		else
			opt.nAlphas = 20;
		end
		
		warning('Invalid nAlphas - using default value of %d.', ...
					opt.nAlphas); 
	end
	
	varargin([a, a+1]) = [];
end

% Initial Alpha
a = find(strcmp(varargin, 'alpha'), 1, 'first');
if(~isempty(a))
	al = varargin{a(1)+1};
	if(isscalar(al) && isnumeric(al) && (((brd || (lcurve && ~opt.alpha_log)) && al > 0) || lcurve))
		opt.alpha = al;
	else
		warning('Invalid alpha guess, using default value of %d.', ...
					opt.alpha); 
	end
	
	varargin([a, a+1]) = [];
end

% Alpha convergence level
a = find(strcmp(varargin, 'alpha_conv'));
if(~isempty(a))
	na = varargin{a(1)+1};
	if(isnumeric(na) && isscalar(na) && na > 0)
		opt.alpha_conv = na;
	else
		warning('Invalid alpha convergence, using default value of %d.',...
						opt.alpha_conv); 
	end
	
	varargin([a, a+1]) = [];
end

% Verbosity
a = find(strcmp(varargin, 'verbose'));
if(~isempty(a))
	v = varargin{a(1)+1};
	if(~isempty(v))
		opt.verbose = logical(v);
	else
		if(opt.verbose)
			str = 'true';
		else
			str = 'false';
		end
		
		warning('Invalid verbosity, using default value of ''%s''.',  ...
					str);		
	end
	
	varargin([a, a+1]) = [];
end

% XScale
a = find(strcmp(varargin, 'xscale'));

if(~isempty(a))
	v = varargin{a(1)+1};
	if(~isempty(v))
		v = svals{strcmp(v, svals)};
	end
	
	if(~isempty(v))
		opt.xscale = v;
	else
		warning('Invalid xscale, using default value of ''%s''', ...
					opt.xscale); 
	end
	
	varargin([a, a+1]) = [];		
end

% YScale
a = find(strcmp(varargin, 'yscale'));

if(~isempty(a))
	v = varargin{a(1)+1};
	if(~isempty(v))
		v = svals{strcmp(v, svals)};
	end
	
	if(~isempty(v))
		opt.yscale = v;
	else
		warning('Invalid yscale, using default value of ''%s''', ...
			opt.yscale); 
	end
	
	varargin([a, a+1]) = [];		
end

% XLabel
a = find(strcmp(varargin, 'xlabel'));

if(~isempty(a))
	v = varargin{a(1)+1};
	
	if(ischar(v))
		opt.xlabel = v;
	end
	
	varargin([a, a+1]) = [];
end

% YLabel
a = find(strcmp(varargin, 'ylabel'));

if(~isempty(a))
	v = varargin{a(1)+1};
	
	if(ischar(v))
		opt.ylabel = v;
	end
	
	varargin([a, a+1]) = [];
end

% Data percentage
a = find(strcmp(varargin, 'dataperc'));
if(~isempty(a))
	dp = varargin{a(1)+1};
	if(~isempty(dp) && isnumeric(dp))
		opt.dataperc = dp(1);
	else
		warning('Invalid data percentage, using default value of %d', ...
			opt.dataperc); 
	end
	
	varargin([a, a+1]) = [];	
end

% Optimization parameters
a = find(strcmp(varargin, 'optims'));
if(~isempty(a))
	os = varargin{a(1)+1};
	
	if(~isempty(os) && isstruct(os))
		o = os;
	else
		warning('Invalid optimset, using default values.'); 
	end
end

a = find(strcmp(varargin, 'alpha_end'));
if(~isempty(a))
	os = varargin{a(1)+1};
	if(~isempty(os) && isscalar(os))
		opt.alpha_end = os;
	else
		if opt.alpha_log
			dflt_val = -8;
		else
			dflt_val = 1e-8;
		end
		
		warning(fprintf('Invalid alpha_end parameter, using default value of %f\n', dflt_val));
		opt.alpha_end = dflt_val;
	end
end

% Alpha list
a = find(strcmp(varargin, 'alpha_list'));
if(~isempty(a))
	os = varargin{a(1)+1};
	if(~isempty(os) && isnumeric(os) && isvector(os))
		opt.alpha_list = os;
	else
		opt.alpha_list = [];
		
		warning('Invalid alpha_list parameter, list will be generated from defined range.'); 
	end
end

% Set default values where unset.
if(exist('o', 'var'))
	o = merge_struct(ops, o);
else
	o = ops;
end

opt.optims = o;
